// Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.

using System.IO;
using System.Threading;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis;
using Xunit;
using System.Collections.Immutable;

namespace Figgle.Generator.Tests;

public partial class FiggleSourceGeneratorTests
{
    private const string ExternalFontFileName = "ANSI Shadow.flf";

    [Theory]
    [InlineData("ANSI Shadow")]
    [InlineData("ansi shadow")]
    public void ExternalFontInAdditionalFiles_RendersText(string fontName)
    {
        string source =
            $$"""
            namespace Test.Namespace
            {
                [GenerateFiggleText("Member", "{{fontName}}", "Figgle")]
                internal partial class DemoUsage
                {
                }
            }
            """;
        string expected =
            """
            // Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.
            
            // <auto-generated>
            //     This code was generated by Figgle.Generator.
            //
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>
            
            namespace Test.Namespace
            {
                partial class DemoUsage
                {
                    public static string Member { get; } = @"███████╗██╗ ██████╗  ██████╗ ██╗     ███████╗
            ██╔════╝██║██╔════╝ ██╔════╝ ██║     ██╔════╝
            █████╗  ██║██║  ███╗██║  ███╗██║     █████╗  
            ██╔══╝  ██║██║   ██║██║   ██║██║     ██╔══╝  
            ██║     ██║╚██████╔╝╚██████╔╝███████╗███████╗
            ╚═╝     ╚═╝ ╚═════╝  ╚═════╝ ╚══════╝╚══════╝
                                                         
            ";
                }
            }
            """;

        var additionalFont = ExternalFontAdditionalText.Create(ExternalFontFileName);

        ValidateOutput(
            source,
            ImmutableArray.Create(additionalFont),
            optionsProvider: null,
            expected);
    }

    [Theory]
    [InlineData("MyCustomFontName", "MyCustomFontName")]
    [InlineData("myCustomFontname", "MyCustomFontName")]
    public void ExternalFontInAdditionalFilesWithExplicitFontNameProperty_RendersText(
        string generateFiggleFontName,
        string externalFontNamePropertyValue)
    {
        string source =
            $$"""
            namespace Test.Namespace
            {
                [GenerateFiggleText("Member", "{{generateFiggleFontName}}", "Figgle")]
                internal partial class DemoUsage
                {
                }
            }
            """;
        string expected =
            """
            // Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.
            
            // <auto-generated>
            //     This code was generated by Figgle.Generator.
            //
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>
            
            namespace Test.Namespace
            {
                partial class DemoUsage
                {
                    public static string Member { get; } = @"███████╗██╗ ██████╗  ██████╗ ██╗     ███████╗
            ██╔════╝██║██╔════╝ ██╔════╝ ██║     ██╔════╝
            █████╗  ██║██║  ███╗██║  ███╗██║     █████╗  
            ██╔══╝  ██║██║   ██║██║   ██║██║     ██╔══╝  
            ██║     ██║╚██████╔╝╚██████╔╝███████╗███████╗
            ╚═╝     ╚═╝ ╚═════╝  ╚═════╝ ╚══════╝╚══════╝
                                                         
            ";
                }
            }
            """;

        var additionalFont = ExternalFontAdditionalText.Create(ExternalFontFileName);

        var optionsProvider = CreateOptionsProvider(
            ExternalFontFileName,
            externalFontNamePropertyValue);

        ValidateOutput(
            source, 
            ImmutableArray.Create(additionalFont),
            optionsProvider,
            expected);

        static TestAnalyzerConfigOptionsProvider CreateOptionsProvider(
            string fontFileName,
            string fontNameProperty)
        {
            var additionalFontOption = new TestAnalyzerConfigOptionsBuilder()
                .AddOption("build_metadata.AdditionalFiles.FontName", fontNameProperty)
                .Build();

            return new TestAnalyzerConfigOptionsProvider(
                getAdditionalFileOptions: f => f.Path == fontFileName
                    ? additionalFontOption
                    : null);
        }
    }

    private sealed class ExternalFontAdditionalText : AdditionalText
    {
        private readonly SourceText _sourceText;

        public static ExternalFontAdditionalText Create(string externalFontPath)
        {
            using var fontStream = File.OpenRead(externalFontPath);

            return new ExternalFontAdditionalText(externalFontPath, fontStream);
        }

        public ExternalFontAdditionalText(string path, Stream externalFont)
        {
            Path = path;
            _sourceText = SourceText.From(externalFont);
        }

        public override string Path { get; }

        public override SourceText? GetText(CancellationToken cancellationToken = default)
        {
            return _sourceText;
        }
    }
}
