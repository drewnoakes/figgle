// Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Figgle.Fonts;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Figgle.Generator;

[Generator(LanguageNames.CSharp)]
internal sealed class EmbedFontSourceGenerator : IIncrementalGenerator
{
    // We are reusing the same diagnostic values from the Figgle source generator for convenience,
    // but this generator "owns" these diagnostics and are conceptually distinct from
    // the diagnostics of the Figgle source generator.
    public static readonly DiagnosticDescriptor UnknownFontNameDiagnostic
        = RenderTextSourceGenerator.UnknownFontNameDiagnostic;

    public static readonly DiagnosticDescriptor InvalidMemberNameDiagnostic
        = RenderTextSourceGenerator.InvalidMemberNameDiagnostic;

    public static readonly DiagnosticDescriptor DuplicateMemberNameDiagnostic
        = RenderTextSourceGenerator.DuplicateMemberNameDiagnostic;

    public static readonly DiagnosticDescriptor TypeIsNotPartialDiagnostic
        = RenderTextSourceGenerator.TypeIsNotPartialDiagnostic;

    public static readonly DiagnosticDescriptor NestedTypeIsNotSupportedDiagnostic
        = RenderTextSourceGenerator.NestedTypeIsNotSupportedDiagnostic;

    public static readonly DiagnosticDescriptor ErrorReadingExternalFontFileDiagnostic = new(
        "FGL0006",
        "Error reading external font file",
        "There were errors when trying to read the external font file '{0}'",
        category: "Figgle",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor TypeMustBeStaticDiagnostic = new(
        "FGL0007",
        "Static type is not supported",
        "The type '{0}' must be a static class",
        category: "Figgle",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private const string AttributeNamespace = "Figgle";
    private const string AttributeName = "EmbedFiggleFontAttribute";

    private const string Header =
        """
        // Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.

        // <auto-generated>
        //     This code was generated by Figgle.Generator.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>

        """;

    public const string AttributeSource =
        $$"""
        {{Header}}
        using System;
        using System.Diagnostics;
        using System.Diagnostics.CodeAnalysis;

        namespace Figgle
        {
            [Conditional("INCLUDE_FIGGLE_GENERATOR_ATTRIBUTES")]
            [ExcludeFromCodeCoverage]
            [DebuggerNonUserCode]
            [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
            internal sealed class {{AttributeName}} : Attribute
            {
                public string MemberName { get; }
                public string FontName { get; }

                public {{AttributeName}}(string memberName, string fontName)
                {
                    MemberName = memberName;
                    FontName = fontName;
                }
            }
        }
        """;

    private static readonly SymbolDisplayFormat _fullyQualifiedFormat
        = SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(
            SymbolDisplayGlobalNamespaceStyle.Omitted);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
        {
            context.AddSource($"{AttributeName}.cs", AttributeSource);
        });

        var generationInfoProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{AttributeNamespace}.{AttributeName}",
            predicate: static (syntaxNode, cancellationToken) => syntaxNode is ClassDeclarationSyntax declaration,
            transform: (context, cancellationToken) =>
            {
                // use hash set to de-dup attributes that are identical.  If an attribute specifies
                // the same member name multiple times with different font names, we will report a diagnostic
                // later in RegisterSourceOutput since we can't report diagnostics from here.
                var attributeInfos = new HashSet<EmbedFontAttributeInfo>(EmbedFontAttributeInfoComparer.Instance);
                foreach (var matchingAttributeData in context.Attributes)
                {
                    attributeInfos.Add(new EmbedFontAttributeInfo(
                        matchingAttributeData.ApplicationSyntaxReference?.GetSyntax(cancellationToken).GetLocation(),
                        (string?)matchingAttributeData.ConstructorArguments[0].Value,
                        (string?)matchingAttributeData.ConstructorArguments[1].Value));
                }

                return new GenerationInfo<EmbedFontAttributeInfo>(
                    (ITypeSymbol)context.TargetSymbol,
                    attributeInfos);
            });

        var generationInfos = generationInfoProvider.ConsolidateAttributeInfosByTypeSymbol(
            EmbedFontAttributeInfoComparer.Instance);

        var externalFontsProvider = context.GetExternalFontsProvider();

        var embedFontInfoProvider = generationInfos.Combine(externalFontsProvider);
        context.RegisterSourceOutput(embedFontInfoProvider, (context, pair) =>
        {
            var (generationInfos, externalFonts) = pair;

            foreach (var kvp in generationInfos)
            {
                var targetType = (ITypeSymbol)kvp.Key;
                var attributeInfos = kvp.Value;

                if (!IsValidTypeForGeneration(context, targetType))
                {
                    return;
                }

                var renderInfoBuilder = ImmutableArray.CreateBuilder<RenderSourceInfo>(
                    attributeInfos.Count);

                var memberNames = new HashSet<string>();
                foreach (var embedFontInfo in attributeInfos)
                {
                    if (!SyntaxFacts.IsValidIdentifier(embedFontInfo.MemberName))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            InvalidMemberNameDiagnostic,
                            embedFontInfo.Location ?? targetType.Locations[0],
                            embedFontInfo.MemberName ?? "unknown"));
                        continue;
                    }

                    if (!memberNames.Add(embedFontInfo.MemberName!))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            DuplicateMemberNameDiagnostic,
                            embedFontInfo.Location ?? targetType.Locations[0],
                            embedFontInfo.MemberName));
                        continue;
                    }

                    if (string.IsNullOrWhiteSpace(embedFontInfo.FontName))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            UnknownFontNameDiagnostic,
                            targetType.Locations[0],
                            embedFontInfo.MemberName ?? "unknown"));
                        continue;
                    }

                    var fontDescription = EmbeddedFontResource.GetFontDescription(embedFontInfo.FontName!);
                    if (fontDescription is null)
                    {
                        // check if the requested font to embed is available in the external fonts
                        var matchingExternalFont = externalFonts.FirstOrDefault(
                            externalFont => externalFont.FontName.Equals(
                                embedFontInfo.FontName,
                                StringComparison.OrdinalIgnoreCase));

                        if (matchingExternalFont is null)
                        {
                            context.ReportDiagnostic(Diagnostic.Create(
                                UnknownFontNameDiagnostic,
                                embedFontInfo.Location ?? targetType.Locations[0],
                                embedFontInfo.FontName));
                            continue;
                        }

                        if (matchingExternalFont.FontDescriptionString is null)
                        {
                            context.ReportDiagnostic(Diagnostic.Create(
                                ErrorReadingExternalFontFileDiagnostic,
                                embedFontInfo.Location ?? targetType.Locations[0],
                                embedFontInfo.FontName));
                            continue;
                        }

                        fontDescription = matchingExternalFont.FontDescriptionString;
                    }

                    renderInfoBuilder.Add(new(
                        embedFontInfo.MemberName!,
                        embedFontInfo.FontName!,
                        fontDescription));
                }

                context.AddSource(
                    $"{targetType.ToDisplayString(_fullyQualifiedFormat)}.g.cs",
                    RenderSource(targetType, renderInfoBuilder.ToImmutable()));
            }
        });
    }

    private static bool IsValidTypeForGeneration(
        SourceProductionContext context,
        ITypeSymbol typeToGenerate)
    {
        // we don't need to check if the type is abstract because the C# compiler will error if
        // a static class is abstract
        if (typeToGenerate.IsStatic == false)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                TypeMustBeStaticDiagnostic,
                typeToGenerate.Locations[0],
                typeToGenerate.ToDisplayString(_fullyQualifiedFormat)));
            return false;
        }

        if (typeToGenerate.ContainingType is not null)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                NestedTypeIsNotSupportedDiagnostic,
                typeToGenerate.Locations[0],
                typeToGenerate.ToDisplayString(_fullyQualifiedFormat)));
            return false;
        }

        // we know the syntax *must* be a class declaration because of the predicate we used in the syntax provider,
        var classSyntax = (ClassDeclarationSyntax)typeToGenerate.DeclaringSyntaxReferences
            .First()
            .GetSyntax(context.CancellationToken);
        if (!classSyntax.Modifiers.Any(SyntaxKind.PartialKeyword))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                TypeIsNotPartialDiagnostic,
                typeToGenerate.Locations[0],
                typeToGenerate.ToDisplayString(_fullyQualifiedFormat)));
            return false;
        }

        return true;
    }

    private static string RenderSource(ITypeSymbol type, ImmutableArray<RenderSourceInfo> fontsToGenerate)
    {
        string ns = type.ContainingNamespace.ToDisplayString(_fullyQualifiedFormat);

        if (ns.Length is not 0)
        {
            return $$"""
            {{Header}}

            using System;
            using System.Collections.Concurrent;
            using Figgle;

            namespace {{ns}}
            {
                static partial class {{type.Name}}
                {
                    private static readonly ConcurrentDictionary<string, FiggleFont> _fontByName = new(StringComparer.Ordinal);
                    private static readonly StringPool _stringPool = new();
                    {{RenderFonts(fontsToGenerate, indentationLevel: 2)}}
                }
            }
            
            """;
        }
        else
        {
            return $$"""
                {{Header}}

                using System;
                using System.Collections.Concurrent;
                using Figgle;

                static partial class {{type.Name}}
                {
                    private static readonly ConcurrentDictionary<string, FiggleFont> _fontByName = new(StringComparer.Ordinal);
                    private static readonly StringPool _stringPool = new();
                    {{RenderFonts(fontsToGenerate, indentationLevel: 1)}}
                }
            
                """;
        }

        static string RenderFonts(ImmutableArray<RenderSourceInfo> renderInfos, int indentationLevel)
        {
            string indentation = new(' ', indentationLevel * 4);
            var builder = new StringBuilder(capacity: 4096);
            builder.AppendLine();

            foreach (var renderInfo in renderInfos)
            {
                builder.Append($$"""
                    {{indentation}}public static FiggleFont {{renderInfo.MemberName}} => _fontByName.GetOrAdd("{{renderInfo.MemberName}}", _ => FiggleFontParser.ParseString({{renderInfo.MemberName}}FontDescription, _stringPool));
                    
                    {{indentation}}private static readonly string {{renderInfo.MemberName}}FontDescription = @"{{renderInfo.FontDescriptionString.Replace("\"", "\"\"")}}";
                    """);
            }

            return builder.ToString();
        }
    }

    private sealed record EmbedFontAttributeInfo(
        Location? Location,
        string? MemberName,
        string? FontName);

    private sealed record RenderSourceInfo(
        string MemberName,
        string FontName,
        string FontDescriptionString);

    private sealed class EmbedFontAttributeInfoComparer : IEqualityComparer<EmbedFontAttributeInfo>
    {
        public static readonly EmbedFontAttributeInfoComparer Instance = new();

        public bool Equals(EmbedFontAttributeInfo? x, EmbedFontAttributeInfo? y)
        {
            if (ReferenceEquals(x, y))
            {
                return true;
            }

            if (x is null || y is null)
            {
                return false;
            }

            // we don't compare the location we're only interested in checking if the attribute
            // arguments are the same.
            return StringComparer.Ordinal.Equals(x.MemberName, y.MemberName)
                && StringComparer.Ordinal.Equals(x.FontName, y.FontName);
        }

        public int GetHashCode(EmbedFontAttributeInfo obj)
        {
            var hash1 = StringComparer.Ordinal.GetHashCode(obj.MemberName);
            var hash2 = StringComparer.Ordinal.GetHashCode(obj.FontName);

            return ((hash1 << 5) + hash1) ^ hash2; // hash1 * 33 ^ hash2
        }
    }
}
