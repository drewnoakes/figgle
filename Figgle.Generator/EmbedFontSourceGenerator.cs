// Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Figgle.Fonts;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Figgle.Generator;

[Generator(LanguageNames.CSharp)]
internal sealed class EmbedFontSourceGenerator : IIncrementalGenerator
{
    // We are reusing the same diagnostic values from the Figgle source generator for convenience,
    // but this generator "owns" these diagnostics and are conceptually distinct from
    // the diagnostics of the Figgle source generator.
    public static readonly DiagnosticDescriptor UnknownFontNameDiagnostic
        = FiggleSourceGenerator.UnknownFontNameDiagnostic;

    public static readonly DiagnosticDescriptor InvalidMemberNameDiagnostic
        = FiggleSourceGenerator.InvalidMemberNameDiagnostic;

    public static readonly DiagnosticDescriptor DuplicateMemberNameDiagnostic
        = FiggleSourceGenerator.DuplicateMemberNameDiagnostic;

    public static readonly DiagnosticDescriptor TypeIsNotPartialDiagnostic
        = FiggleSourceGenerator.TypeIsNotPartialDiagnostic;

    public static readonly DiagnosticDescriptor NestedTypeIsNotSupportedDiagnostic
        = FiggleSourceGenerator.NestedTypeIsNotSupportedDiagnostic;

    public static readonly DiagnosticDescriptor ErrorReadingExternalFontFileDiagnostic = new(
        "FGL0006",
        "Error reading external font file",
        "There were errors when trying to read the external font file '{0}'",
        category: "Figgle",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor TypeMustBeStaticDiagnostic = new(
        "FGL0007",
        "Static type is not supported",
        "The type '{0}' must be a static class",
        category: "Figgle",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private const string AttributeNamespace = "Figgle";
    private const string AttributeName = "EmbedFiggleFontAttribute";

    private const string Header =
        """
        // Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.

        // <auto-generated>
        //     This code was generated by Figgle.Generator.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>

        """;

    public const string AttributeSource =
        $$"""
        {{Header}}
        using System;
        using System.Diagnostics;
        using System.Diagnostics.CodeAnalysis;

        namespace Figgle
        {
            [Conditional("INCLUDE_FIGGLE_GENERATOR_ATTRIBUTES")]
            [ExcludeFromCodeCoverage]
            [DebuggerNonUserCode]
            [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
            internal sealed class {{AttributeName}} : Attribute
            {
                public string MemberName { get; }
                public string FontName { get; }

                public {{AttributeName}}(string memberName, string fontName)
                {
                    MemberName = memberName;
                    FontName = fontName;
                }
            }
        }
        """;

    private static readonly SymbolDisplayFormat _fullyQualifiedFormat
        = SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(
            SymbolDisplayGlobalNamespaceStyle.Omitted);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
        {
            context.AddSource($"{AttributeName}.cs", AttributeSource);
        });

        var generationInfoProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{AttributeNamespace}.{AttributeName}",
            predicate: static (syntaxNode, cancellationToken) => syntaxNode is ClassDeclarationSyntax declaration,
            transform: (context, cancellationToken) =>
            {
                var attributeInfos = new HashSet<EmbedFontAttributeInfo>();
                foreach (var matchingAttributeData in context.Attributes)
                {
                    attributeInfos.Add(new EmbedFontAttributeInfo(
                        matchingAttributeData.ApplicationSyntaxReference?.GetSyntax(cancellationToken).GetLocation(),
                        (string?)matchingAttributeData.ConstructorArguments[0].Value,
                        (string?)matchingAttributeData.ConstructorArguments[1].Value));
                }

                return new GenerationInfo(
                    (ITypeSymbol)context.TargetSymbol,
                    attributeInfos);
            });

        var externalFontsProvider = context.AdditionalTextsProvider
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Where(pair => pair.Left.Path.EndsWith(".flf", StringComparison.OrdinalIgnoreCase))
            .Select(static (pair, cancellationToken) =>
            {
                var (additionalFile, optionsProvider) = pair;
                var additionalFileOptions = optionsProvider.GetOptions(additionalFile);

                additionalFileOptions.TryGetValue("build_metadata.AdditionalFiles.FontName", out var fontNameValue);
                var fontName = fontNameValue ?? Path.GetFileNameWithoutExtension(additionalFile.Path);

                return new ExternalFont(
                    fontName,
                    // GetText returns null if there are errors reading the file.
                    additionalFile.GetText(cancellationToken)?.ToString());
            })
            .Collect();

        var embedFontInfoProvider = generationInfoProvider.Combine(externalFontsProvider);
        context.RegisterSourceOutput(embedFontInfoProvider, (context, pair) =>
        {
            var (generationInfo, externalFonts) = pair;
            if (!IsValidTypeForGeneration(context, generationInfo.TargetType))
            {
                return;
            }

            var renderInfoBuilder = ImmutableArray.CreateBuilder<RenderSourceInfo>(
                generationInfo.FontsToGenerate.Count);

            var memberNames = new HashSet<string>();
            foreach (var embedFontInfo in generationInfo.FontsToGenerate)
            {
                if (!SyntaxFacts.IsValidIdentifier(embedFontInfo.MemberName))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        InvalidMemberNameDiagnostic,
                        embedFontInfo.Location ?? generationInfo.TargetType.Locations[0],
                        embedFontInfo.FontName ?? "unknown"));
                    continue;
                }

                if (!memberNames.Add(embedFontInfo.MemberName!))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        DuplicateMemberNameDiagnostic,
                        embedFontInfo.Location ?? generationInfo.TargetType.Locations[0],
                        embedFontInfo.MemberName));
                    continue;
                }

                if (string.IsNullOrWhiteSpace(embedFontInfo.FontName))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        UnknownFontNameDiagnostic,
                        generationInfo.TargetType.Locations[0],
                        embedFontInfo.MemberName ?? "unknown"));
                    continue;
                }

                var fontDescription = EmbeddedFontResource.GetFontDescription(embedFontInfo.FontName!);
                if (fontDescription is null)
                {
                    // check if the requested font to embed is available in the external fonts
                    var matchingExternalFont = externalFonts.FirstOrDefault(
                        externalFont => externalFont.FontName.Equals(
                            embedFontInfo.FontName,
                            StringComparison.OrdinalIgnoreCase));

                    if (matchingExternalFont is null)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            UnknownFontNameDiagnostic,
                            embedFontInfo.Location ?? generationInfo.TargetType.Locations[0],
                            embedFontInfo.FontName));
                        continue;
                    }

                    if (matchingExternalFont.FontDescriptionString is null)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            ErrorReadingExternalFontFileDiagnostic,
                            embedFontInfo.Location ?? generationInfo.TargetType.Locations[0],
                            embedFontInfo.FontName));
                        continue;
                    }

                    fontDescription = matchingExternalFont.FontDescriptionString;
                }

                renderInfoBuilder.Add(new(
                    embedFontInfo.MemberName!,
                    embedFontInfo.FontName!,
                    fontDescription));
            }

            context.AddSource(
                $"{generationInfo.TargetType.Name}.g.cs",
                RenderSource(generationInfo.TargetType, renderInfoBuilder.ToImmutable()));
        });
    }

    private static bool IsValidTypeForGeneration(
        SourceProductionContext context,
        ITypeSymbol typeToGenerate)
    {
        // we don't need to check if the type is abstract because the C# compiler will error if
        // a static class is abstract
        if (typeToGenerate.IsStatic == false)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                TypeMustBeStaticDiagnostic,
                typeToGenerate.Locations[0],
                typeToGenerate.ToDisplayString(_fullyQualifiedFormat)));
            return false;
        }

        if (typeToGenerate.ContainingType is not null)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                NestedTypeIsNotSupportedDiagnostic,
                typeToGenerate.Locations[0],
                typeToGenerate.ToDisplayString(_fullyQualifiedFormat)));
            return false;
        }

        return true;
    }

    private string RenderSource(ITypeSymbol type, ImmutableArray<RenderSourceInfo> fontsToGenerate)
    {
        return $$"""
            {{Header}}

            using System;
            using System.Collections.Concurrent;
            using Figgle;

            namespace {{type.ContainingNamespace.ToDisplayString(_fullyQualifiedFormat)}}
            {
                {{GetAccessibility(type.DeclaredAccessibility)}} static partial class {{type.Name}}
                {
                    private static readonly ConcurrentDictionary<string, FiggleFont> _fontByName = new(StringComparer.Ordinal);
                    private static readonly StringPool _stringPool = new();
                    {{RenderFonts(fontsToGenerate, indentationLevel: 2)}}
                }
            }
            
            """;

        static string RenderFonts(ImmutableArray<RenderSourceInfo> renderInfos, int indentationLevel)
        {
            string indentation = new(' ', indentationLevel * 4);
            var builder = new StringBuilder();
            builder.AppendLine();

            foreach (var renderInfo in renderInfos)
            {
                builder.Append($$"""
                    {{indentation}}public static FiggleFont {{renderInfo.MemberName}} => _fontByName.GetOrAdd("{{renderInfo.MemberName}}", _ => FiggleFontParser.ParseString({{renderInfo.MemberName}}FontDescription, _stringPool));
                    
                    {{indentation}}private static readonly string {{renderInfo.MemberName}}FontDescription = @"{{renderInfo.FontDescriptionString.Replace("\"", "\"\"")}}";
                    """);
            }

            return builder.ToString();
        }
    }

    private static string GetAccessibility(Accessibility declaredAccessibility)
    {
        return declaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "protected internal",
            Accessibility.NotApplicable => string.Empty,
            _ => throw new NotImplementedException($"Unexpected accessibility '{declaredAccessibility}'"),
        };
    }

    private sealed record EmbedFontAttributeInfo(
        Location? Location,
        string? MemberName,
        string? FontName);

    private sealed record ExternalFont(
        string FontName,
        string? FontDescriptionString);

    private sealed record GenerationInfo(
        ITypeSymbol TargetType,
        HashSet<EmbedFontAttributeInfo> FontsToGenerate);

    private sealed record RenderSourceInfo(
        string MemberName,
        string FontName,
        string FontDescriptionString);
}
