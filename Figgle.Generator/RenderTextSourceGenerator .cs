// Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Figgle.Fonts;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Figgle.Generator;

[Generator]
public sealed class RenderTextSourceGenerator : IIncrementalGenerator
{
    public static readonly DiagnosticDescriptor UnknownFontNameDiagnostic = new(
        "FGL0001",
        "Unknown font name",
        "A font with name '{0}' was not found",
        category: "Figgle",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor InvalidMemberNameDiagnostic = new(
        "FGL0002",
        "Invalid member name",
        "The string '{0}' is not a valid member name",
        category: "Figgle",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor DuplicateMemberNameDiagnostic = new(
        "FGL0003",
        "Duplicate member name",
        "Member '{0}' has already been declared",
        category: "Figgle",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor TypeIsNotPartialDiagnostic = new(
        "FGL0004",
        "Type must be partial",
        "Type '{0}' must be partial",
        category: "Figgle",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public static readonly DiagnosticDescriptor NestedTypeIsNotSupportedDiagnostic = new(
        "FGL0005",
        "Figgle generation does not support nested types",
        "Unable to generate Figgle text for nested type '{0}'. Generation is only supported for non-nested types.",
        category: "Figgle",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private const string Header =
        """
        // Copyright Drew Noakes. Licensed under the Apache-2.0 license. See the LICENSE file for more details.

        // <auto-generated>
        //     This code was generated by Figgle.Generator.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>

        """;

    private const string AttributeNamespace = "Figgle";
    private const string AttributeName = "GenerateFiggleTextAttribute";

    public const string AttributeSource =
        $$"""
        {{Header}}
        using System;
        using System.Diagnostics;
        using System.Diagnostics.CodeAnalysis;

        namespace {{AttributeNamespace}}
        {
            [Conditional("INCLUDE_FIGGLE_GENERATOR_ATTRIBUTES")]
            [ExcludeFromCodeCoverage]
            [DebuggerNonUserCode]
            [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
            internal sealed class {{AttributeName}} : Attribute
            {
                public string MemberName { get; }
                public string FontName { get; }
                public string SourceText { get; }

                public {{AttributeName}}(string memberName, string fontName, string sourceText)
                {
                    MemberName = memberName;
                    FontName = fontName;
                    SourceText = sourceText;
                }
            }
        }
        """;

    private static readonly SymbolDisplayFormat _fullyQualifiedFormat
        = SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(
            SymbolDisplayGlobalNamespaceStyle.Omitted);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
        {
           context.AddSource($"{AttributeName}.cs", AttributeSource);
        });

        var generationInfoProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{AttributeNamespace}.{AttributeName}",
            predicate: static (syntaxNode, cancellationToken) => syntaxNode is ClassDeclarationSyntax,
            transform: (context, cancellationToken) =>
            {
                // use hash set to de-dup attributes that are identical.  If an attribute specifies
                // the same member name multiple times with different font names, we will report a diagnostic
                // later in RegisterSourceOutput since we can't report diagnostics from here.
                var attributeInfos = new HashSet<RenderItem>(RenderItemComparer.Instance);
                foreach (var matchingAttributeData in context.Attributes)
                {
                    attributeInfos.Add(new RenderItem(
                        matchingAttributeData.ApplicationSyntaxReference?.GetSyntax(cancellationToken).GetLocation(),
                        (string?)matchingAttributeData.ConstructorArguments[0].Value,
                        (string?)matchingAttributeData.ConstructorArguments[1].Value,
                        (string?)matchingAttributeData.ConstructorArguments[2].Value));
                }

                return new GenerationInfo(
                    (ITypeSymbol)context.TargetSymbol,
                    attributeInfos);
            });

        var externalFontsProvider = context.GetExternalFontsProvider();
        var embedFontInfoProvider = generationInfoProvider.Collect().Combine(externalFontsProvider);

        context.RegisterSourceOutput(embedFontInfoProvider, (context, pair)=>
        {
            var (generationInfos, externalFonts) = pair;

            // Group by the target type in case there are multiple partial definitions
            // for a single type, so that we can generate one file per type.
            var typeToGenerateGroup = generationInfos.GroupBy(
                keySelector: info => info.TargetType,
                elementSelector: info => info.AttributeInfos,
                comparer: SymbolEqualityComparer.Default);

            foreach (var generateGroup in typeToGenerateGroup)
            {
                var targetType = (ITypeSymbol)generateGroup.Key!;

                // There may be multiple partial definitions for the same symbol,
                // each listing different attributes that may or may not repeat.
                // By merging all attributes into a single hash set, we ensure there
                // are no repeats and we generate all source in one file per type.
                var attributeInfos = new HashSet<RenderItem>(RenderItemComparer.Instance);
                foreach (var attributeInfo in generateGroup)
                {
                    attributeInfos.UnionWith(attributeInfo);
                }

                if (!IsValidTypeForGeneration(context, targetType))
                {
                    return;
                }

                var renderInfoBuilder = ImmutableArray.CreateBuilder<RenderSourceInfo>(
                    attributeInfos.Count);

                var memberNames = new HashSet<string>();
                foreach (var generateFiggleInfo in attributeInfos)
                {
                    if (!SyntaxFacts.IsValidIdentifier(generateFiggleInfo.MemberName))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            InvalidMemberNameDiagnostic,
                            generateFiggleInfo.AttributeLocation ?? targetType.Locations[0],
                            generateFiggleInfo.MemberName ?? "unknown"));
                        continue;
                    }

                    if (!memberNames.Add(generateFiggleInfo.MemberName!))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            DuplicateMemberNameDiagnostic,
                            generateFiggleInfo.AttributeLocation ?? targetType.Locations[0],
                            generateFiggleInfo.MemberName));
                        continue;
                    }

                    if (targetType.GetMembers(generateFiggleInfo.MemberName!).Any())
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            DuplicateMemberNameDiagnostic,
                            targetType.Locations[0],
                            generateFiggleInfo.MemberName));
                        continue;
                    }

                    if (string.IsNullOrWhiteSpace(generateFiggleInfo.FontName))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(
                            UnknownFontNameDiagnostic,
                            targetType.Locations[0],
                            generateFiggleInfo.MemberName ?? "unknown"));
                        continue;
                    }

                    var figgleFont = FiggleFonts.TryGetByName(generateFiggleInfo.FontName!);
                    if (figgleFont is null)
                    {
                        // check if the requested font to use is available in the external fonts
                        var matchingExternalFont = externalFonts.FirstOrDefault(
                            externalFont => externalFont.FontName.Equals(
                                generateFiggleInfo.FontName,
                                StringComparison.OrdinalIgnoreCase));

                        if (matchingExternalFont is null || matchingExternalFont.FontDescriptionString is null)
                        {
                            context.ReportDiagnostic(Diagnostic.Create(
                                UnknownFontNameDiagnostic,
                                generateFiggleInfo.AttributeLocation ?? targetType.Locations[0],
                                generateFiggleInfo.FontName));
                            continue;
                        }

                        figgleFont = FiggleFontParser.ParseString(matchingExternalFont.FontDescriptionString);
                    }

                    renderInfoBuilder.Add(new(
                        generateFiggleInfo.MemberName!,
                        generateFiggleInfo.SourceText!,
                        figgleFont));
                }

                context.AddSource(
                    GetGeneratedFileName(targetType),
                    RenderSource(targetType, renderInfoBuilder.ToImmutable()));

                static string GetGeneratedFileName(ITypeSymbol type)
                {
                    return $"{type.ToDisplayString(_fullyQualifiedFormat)}.g.cs";
                }
            }
        });
    }

    private string RenderSource(ITypeSymbol type, ImmutableArray<RenderSourceInfo> fontsToGenerate)
    {
        if (type.ContainingNamespace.IsGlobalNamespace)
        {
            return $$"""
                {{Header}}
                partial class {{type.Name}}
                {{{RenderFonts(fontsToGenerate, indentationLevel: 1)}}
                }
                """;
        }

        return $$"""
            {{Header}}
            namespace {{type.ContainingNamespace.ToDisplayString(_fullyQualifiedFormat)}}
            {
                partial class {{type.Name}}
                {{{RenderFonts(fontsToGenerate, indentationLevel: 2)}}
                }
            }
            """;

        static string RenderFonts(ImmutableArray<RenderSourceInfo> renderInfos, int indentationLevel)
        {
            string indentation = new(' ', indentationLevel * 4);
            var builder = new StringBuilder(capacity: 4096);

            foreach (var renderInfo in renderInfos)
            {
                var text = renderInfo.Font.Render(renderInfo.SourceText);

                builder.AppendLine();
                builder.Append($$"""
                    {{indentation}}public static string {{renderInfo.MemberName}} { get; } = @"{{text.Replace("\"", "\"\"")}}";
                    """);
            }

            return builder.ToString();
        }
    }

    private static bool IsValidTypeForGeneration(
        SourceProductionContext context,
        ITypeSymbol typeToGenerate)
    {
        if (typeToGenerate.ContainingType is not null)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                NestedTypeIsNotSupportedDiagnostic,
                typeToGenerate.Locations[0],
                typeToGenerate.ToDisplayString(_fullyQualifiedFormat)));
            return false;
        }

        // we know the syntax *must* be a class declaration because of the predicate we used in the syntax provider,
        var classSyntax = (ClassDeclarationSyntax)typeToGenerate.DeclaringSyntaxReferences
            .First()
            .GetSyntax(context.CancellationToken);
        if (!classSyntax.Modifiers.Any(SyntaxKind.PartialKeyword))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                TypeIsNotPartialDiagnostic,
                typeToGenerate.Locations[0],
                typeToGenerate.ToDisplayString(_fullyQualifiedFormat)));
            return false;
        }

        return true;
    }

    private sealed record RenderItem(
        Location? AttributeLocation,
        string? MemberName,
        string? FontName,
        string? SourceText);

    private sealed record GenerationInfo(
        ITypeSymbol TargetType,
        HashSet<RenderItem> AttributeInfos);

    private sealed record RenderSourceInfo(
        string MemberName,
        string SourceText,
        FiggleFont Font);

    private sealed class RenderItemComparer : IEqualityComparer<RenderItem>
    {
        public static readonly RenderItemComparer Instance = new();

        public bool Equals(RenderItem? x, RenderItem? y)
        {
            if (ReferenceEquals(x, y))
            {
                return true;
            }

            if (x is null || y is null)
            {
                return false;
            }

            return x.MemberName == y.MemberName
                && x.FontName == y.FontName
                && x.SourceText == y.SourceText;
        }

        public int GetHashCode(RenderItem obj)
        {
            return (obj.MemberName, obj.FontName, obj.SourceText).GetHashCode();
        }
    }
}
